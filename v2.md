TODO:

The new version should be a pluggable system. So a plugin should deliver the following 4 elements:

- A list of Return-Type registrations (register a handler for a certain type, exception: Promise)
- A list of ParamDecorators that are registered in giuseppe
- A list of RouteDecorators that are registered in giuseppe
- A list of Route/Controller Modificators that are registered in giuseppe

A route decorator does ultimately create a route (like @Get) and a modificator does change the behaviour
(like @Version).

same name -> exception.

route / controller modificators:
pre route hook
post route hook
route ID -> to check if duplicates are registered.


route decorator:
creates a route in a controller, defines a wrapper for the route.
(i.e. (request, response) => ...)
should implement a register route method, that actually builds the route and the function


"build": "tsc --outDir .",
    "clean": "rimraf build coverage",
    "pretest": "npm run clean && tsc --sourceMap",
    "test": "istanbul cover -x \"**/*.spec.*\" _mocha -- --ui bdd \"./build/**/*.spec.js\"",
    "posttest": "remap-istanbul -i coverage/coverage.json -o coverage/html-report -t html -e _test",
    "precitest": "npm run bootstrap && npm run clean && tsc --sourceMap",
    "citest": "istanbul cover -x \"**/*.spec.*\" _mocha --report lcovonly -- --ui bdd \"./build/**/*.spec.js\"",
    "postcitest": "remap-istanbul -i coverage/coverage.json -o coverage/lcov-mapped.info -t lcovonly -e _test",
    "develop": "npm run clean && tsc -p ."


TODO:
- documentation
- import 'reflect-metadata'; (like, everywhere)
- test all the things
